/**
 * Template for generating apiClient.ts boundary layer
 */
export const API_CLIENT_TEMPLATE = `/**
 * API Client - Centralized fetch boundary for fixture injection
 * Generated by mcp-fixtures
 */

// Import fixture injection utilities
let injectedFetch: typeof fetch = globalThis.fetch;

// Initialize fixture injection if available
try {
  if (typeof window !== 'undefined') {
    // Browser environment - check for service worker fixtures
    // The service worker will handle interception automatically
    injectedFetch = globalThis.fetch;
  } else {
    // Node.js environment - use fetch interceptor if available
    const { createInjectedFetch } = await import('@app/fixtures-fetch');
    injectedFetch = createInjectedFetch({
      enableLogging: process.env.NODE_ENV === 'development'
    });
  }
} catch (error) {
  // Fallback to regular fetch if fixture utilities not available
  console.log('ℹ️  Fixture injection not available, using regular fetch');
  injectedFetch = globalThis.fetch;
}

/**
 * Centralized API client with fixture injection support
 */
class ApiClient {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;

  constructor(baseURL = '', defaultHeaders: Record<string, string> = {}) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...defaultHeaders
    };
  }

  /**
   * Enhanced fetch with automatic fixture injection
   */
  async fetch(
    input: RequestInfo | URL, 
    init?: RequestInit
  ): Promise<Response> {
    // Resolve URL
    const url = typeof input === 'string' ? input : 
                input instanceof URL ? input.href : 
                (input as Request).url;

    // Merge headers
    const headers = {
      ...this.defaultHeaders,
      ...(init?.headers ? Object.fromEntries(
        new Headers(init.headers).entries()
      ) : {})
    };

    // Create full URL if relative
    const fullUrl = url.startsWith('/') && this.baseURL ? 
      \`\${this.baseURL}\${url}\` : url;

    // Make request with injected fetch
    return injectedFetch(fullUrl, {
      ...init,
      headers
    });
  }

  /**
   * Convenience methods
   */
  async get(url: string, init?: RequestInit): Promise<Response> {
    return this.fetch(url, { ...init, method: 'GET' });
  }

  async post(url: string, body?: any, init?: RequestInit): Promise<Response> {
    return this.fetch(url, {
      ...init,
      method: 'POST',
      body: body ? JSON.stringify(body) : undefined
    });
  }

  async put(url: string, body?: any, init?: RequestInit): Promise<Response> {
    return this.fetch(url, {
      ...init,
      method: 'PUT',
      body: body ? JSON.stringify(body) : undefined
    });
  }

  async delete(url: string, init?: RequestInit): Promise<Response> {
    return this.fetch(url, { ...init, method: 'DELETE' });
  }

  /**
   * JSON response helpers
   */
  async getJSON<T = any>(url: string, init?: RequestInit): Promise<T> {
    const response = await this.get(url, init);
    return response.json();
  }

  async postJSON<T = any>(url: string, body?: any, init?: RequestInit): Promise<T> {
    const response = await this.post(url, body, init);
    return response.json();
  }
}

// Create default instance
const apiClient = new ApiClient(
  process.env.API_BASE_URL || process.env.NEXT_PUBLIC_API_URL || ''
);

export default apiClient;
export { ApiClient };

// Type exports for better TypeScript support
export type { RequestInfo } from '@types/node';
`;

/**
 * Generate apiClient.ts file content with custom configuration
 */
export function generateApiClient(options: {
  baseURL?: string;
  includeHelpers?: boolean;
  typescript?: boolean;
}): string {
  if (!options.typescript) {
    // Return JavaScript version
    return API_CLIENT_TEMPLATE.replace(/: [^=]+ =/g, ' =').replace(/: [^)]+ \)/g, ')');
  }
  
  return API_CLIENT_TEMPLATE;
}
